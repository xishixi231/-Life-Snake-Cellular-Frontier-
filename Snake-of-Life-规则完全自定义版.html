<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>Snake of Life: è§„åˆ™å®Œå…¨è‡ªå®šä¹‰ç‰ˆ</title>
    <style>
        body {
            background-color: #050505;
            color: #ddd;
            font-family: 'Segoe UI', sans-serif;
            margin: 0;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
        }
        
        #ui-bar {
            position: fixed; top: 15px; left: 50%; transform: translateX(-50%); z-index: 1000;
            display: flex; gap: 12px;
            background: rgba(17, 17, 17, 0.85); backdrop-filter: blur(6px);
            padding: 10px 20px; border: 1px solid rgba(255, 255, 255, 0.15); border-radius: 30px;
            width: auto; min-width: 750px;
            font-size: 14px; align-items: center;
            box-shadow: 0 8px 32px rgba(0,0,0,0.6);
            user-select: none;
        }
        
        .stat { color: #aaa; white-space: nowrap; margin: 0 5px; }
        .val { color: #fff; font-weight: bold; font-size: 1.2em; }
        .mode-badge { padding: 4px 10px; border-radius: 6px; font-size: 12px; font-weight: bold; margin-right: 10px; }
        .mode-flood { background: #003366; color: #00ccff; border: 1px solid #005588; }
        .mode-drought { background: #553300; color: #ffcc00; border: 1px solid #885500; }
        .mode-dark { background: #440044; color: #ff00ff; border: 1px solid #880088; }
        .mode-custom { background: #224400; color: #88ff00; border: 1px solid #44aa00; }
        
        #ctrl-mode { font-weight: bold; padding: 2px 6px; border-radius: 4px; border: 1px solid #555; font-size: 12px; transition:0.2s; }
        .ctrl-direct { background: #004400; color: #0f0; border-color: #006600; }
        .ctrl-rts { background: #004466; color: #0ff; border-color: #006688; }

        button {
            background: #333; color: #fff; border: 1px solid #555;
            padding: 6px 15px; cursor: pointer; font-size: 13px; border-radius: 6px; transition: 0.2s; margin-left: 5px;
        }
        button:hover { background: #444; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        #btn-upgrade { background: linear-gradient(180deg, #006600, #004400); border-color: #007700; }
        
        canvas { display: block; background-color: #050505; cursor: crosshair; }

        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.92); display: flex; flex-direction: column;
            align-items: center; justify-content: center; z-index: 2000; backdrop-filter: blur(5px);
        }
        .modal-box {
            background: #111; border: 1px solid #333; padding: 40px; border-radius: 12px;
            text-align: center; box-shadow: 0 0 60px rgba(0,255,0,0.05); width: 500px;
            max-height: 80vh; overflow-y: auto;
        }
        .modal-box-wide {
            width: 700px;
        }
        .modal-box-xwide {
            width: 800px;
        }
        .mode-select-btn {
            display: block; width: 100%; margin: 12px 0; padding: 18px; font-size: 18px;
            font-weight: bold; border: none; border-radius: 8px; cursor: pointer; text-align: left;
        }
        .mode-select-btn:hover { transform: scale(1.02); }
        .mode-desc { font-size: 13px; opacity: 0.8; font-weight: normal; display: block; margin-top: 4px; }
        
        /* è‡ªå®šä¹‰æ¨¡å¼è¡¨å•æ ·å¼ */
        .config-section {
            background: #222; border: 1px solid #444; border-radius: 8px; padding: 15px; margin: 15px 0;
        }
        .config-section h3 {
            margin-top: 0; color: #88ffaa; border-bottom: 1px solid #444; padding-bottom: 5px;
        }
        .config-row {
            display: flex; align-items: center; margin: 10px 0;
        }
        .config-label {
            flex: 1; min-width: 180px; color: #aaa;
        }
        .config-value {
            flex: 2; display: flex; align-items: center;
        }
        .config-value input[type="range"] {
            flex: 1; margin-right: 10px;
        }
        .config-number {
            width: 60px; text-align: center; background: #333; color: #fff; border: 1px solid #555;
            padding: 5px; border-radius: 4px;
        }
        .color-picker-container {
            display: flex; align-items: center; gap: 10px;
        }
        .color-preview {
            width: 30px; height: 20px; border: 1px solid #666; border-radius: 3px;
        }
        .color-picker {
            width: 100px; background: #333; border: 1px solid #555; border-radius: 4px; padding: 2px;
        }
        .toggle-switch {
            position: relative; display: inline-block; width: 50px; height: 24px;
        }
        .toggle-switch input { opacity: 0; width: 0; height: 0; }
        .toggle-slider {
            position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0;
            background-color: #333; transition: .4s; border-radius: 24px;
        }
        .toggle-slider:before {
            position: absolute; content: ""; height: 16px; width: 16px; left: 4px; bottom: 4px;
            background-color: #fff; transition: .4s; border-radius: 50%;
        }
        input:checked + .toggle-slider { background-color: #0a0; }
        input:checked + .toggle-slider:before { transform: translateX(26px); }
        
        /* æ ‡ç­¾é¡µæ ·å¼ */
        .tab-container {
            display: flex; border-bottom: 1px solid #444; margin-bottom: 20px; overflow-x: auto;
        }
        .tab-button {
            background: none; border: none; color: #aaa; padding: 10px 15px; cursor: pointer; white-space: nowrap;
            border-bottom: 2px solid transparent; margin-bottom: -1px;
        }
        .tab-button.active {
            color: #0ff; border-bottom-color: #0ff;
        }
        .tab-content { display: none; }
        .tab-content.active { display: block; }
        
        /* è§„åˆ™è‡ªå®šä¹‰ç‰¹å®šæ ·å¼ */
        .rules-container {
            display: flex; gap: 20px; margin-bottom: 20px;
        }
        .rules-input {
            flex: 1;
        }
        .rules-visual {
            flex: 1;
        }
        .rule-input-group {
            margin-bottom: 15px;
        }
        .rule-input-group label {
            display: block; margin-bottom: 5px; color: #88ffaa;
        }
        .rule-text-input {
            width: 100%; padding: 8px; background: #333; border: 1px solid #555; border-radius: 4px; color: #fff;
        }
        .rule-text-input:focus {
            outline: none; border-color: #0ff;
        }
        .rules-grid {
            display: flex; flex-direction: column; gap: 10px;
        }
        .rules-row {
            display: flex; gap: 10px; align-items: center;
        }
        .rules-title {
            width: 100px; color: #aaa; text-align: center;
        }
        .rules-cells {
            display: flex; gap: 5px;
        }
        .rule-cell {
            width: 30px; height: 30px; display: flex; align-items: center; justify-content: center;
            background: #333; border: 2px solid #555; border-radius: 4px; cursor: pointer;
            font-weight: bold; transition: all 0.2s;
        }
        .rule-cell:hover {
            border-color: #888;
        }
        .rule-cell.birth.active {
            background: #0a0; border-color: #0f0; color: #000;
        }
        .rule-cell.survive.active {
            background: #00a; border-color: #00f; color: #fff;
        }
        .rule-presets {
            display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; margin-top: 20px;
        }
        .rule-preset {
            padding: 8px; background: #222; border: 1px solid #444; border-radius: 4px; cursor: pointer;
            text-align: center; transition: all 0.2s;
        }
        .rule-preset:hover {
            background: #333; border-color: #555;
        }
        .rule-preset.active {
            background: #224400; border-color: #44aa00;
        }
        .rules-preview {
            margin-top: 20px; padding: 15px; background: #222; border-radius: 4px; border: 1px solid #444;
        }
        .rules-preview h4 {
            margin-top: 0; color: #88ffaa;
        }
        .preview-canvas-container {
            display: flex; justify-content: center; margin-top: 10px;
        }
        .preview-canvas {
            background: #000; border: 1px solid #444;
        }
        
        #controls-hint {
            position: fixed; bottom: 20px; width: 100%; text-align: center;
            color: #555; font-size: 12px; z-index: 1000; pointer-events: none;
            text-shadow: 0 1px 2px #000;
        }
    </style>
</head>
<body>

    <div id="ui-bar">
        <span id="current-mode-badge" class="mode-badge mode-custom">è‡ªå®šä¹‰</span>
        <div class="stat">æ¨¡å¼: <span id="ctrl-mode" class="ctrl-direct">ç‰µå¼• [Q]</span></div>
        <div class="stat">é•¿: <span id="len-val" class="val">0</span></div>
        <div class="stat">å›¾: <span id="map-val"></span></div>
        <div class="stat">ç¼©æ”¾: <span id="zoom-val">100%</span></div>
        <div style="flex-grow:1"></div>
        <button onclick="upgradeMap()" id="btn-upgrade">æ‰©å¤§åœ°å›¾ [E]</button>
        <button onclick="togglePause()" id="btn-pause">æš‚åœ [P]</button>
        <button onclick="toggleMute()" id="btn-mute">éŸ³æ•ˆ: å¼€</button>
        <button onclick="showStartMenu()">èœå•</button>
    </div>

    <canvas id="gameCanvas"></canvas>
    
    <div id="controls-hint">
        [æ»šè½®] ç¼©æ”¾ | [Q] åˆ‡æ¢æ¨¡å¼ | [å·¦é”®] ç§»åŠ¨/å¯»è·¯ | [E] æ‰©å¤§ | [WASD] ç©¿å¢™å¾®æ“
    </div>

    <!-- ä¸»èœå• -->
    <div id="start-modal" class="modal-overlay">
        <div class="modal-box">
            <div style="font-size:32px; margin-bottom:30px; color:#fff; letter-spacing:4px; font-weight:100">ç”Ÿæ€é€‰æ‹©</div>
            <button class="mode-select-btn btn-flood" onclick="startGame('flood')">
                ğŸŒŠ ä¸°é¥¶ä¹‹æµ·
                <span class="mode-desc">å‰æœŸä¿é€ï¼ŒåæœŸæ–­ç²® | é€‚åˆæ–°æ‰‹ä½“éªŒåå™¬å¿«æ„Ÿ</span>
            </button>
            <button class="mode-select-btn btn-drought" onclick="startGame('drought')">
                ğŸœï¸ è’èŠœåºŸåœŸ
                <span class="mode-desc">å¿…é¡»ä½¿ç”¨[å³é”®]é‡å‹æŠ€èƒ½å¼€è’ | ç­–ç•¥ä¸ç§ç”°</span>
            </button>
            <button class="mode-select-btn btn-dark" onclick="startGame('dark')">
                ğŸŒ² é»‘æš—æ£®æ—
                <span class="mode-desc">èµ„æºé€‚ä¸­ | é«˜åº¦å±é™© | ç»å…¸åšå¼ˆä½“éªŒ</span>
            </button>
            <button class="mode-select-btn" style="background:linear-gradient(90deg, #224400, #112200); color:#88ff00; border:1px solid #44aa00" onclick="showCustomConfig()">
                âš™ï¸ è‡ªå®šä¹‰æ¨¡å¼
                <span class="mode-desc">å®Œå…¨è‡ªå®šä¹‰æ‰€æœ‰å‚æ•° | æ‰“é€ ä½ çš„ä¸“å±ä¸–ç•Œ</span>
            </button>
        </div>
    </div>
    
    <!-- è‡ªå®šä¹‰é…ç½®ç•Œé¢ -->
    <div id="custom-modal" class="modal-overlay" style="display:none">
        <div class="modal-box modal-box-xwide">
            <div style="font-size:32px; margin-bottom:30px; color:#88ff00; letter-spacing:4px; font-weight:100">è‡ªå®šä¹‰é…ç½®</div>
            
            <div class="tab-container">
                <button class="tab-button active" onclick="switchTab('tab-basic')">åŸºç¡€ç”Ÿæ€</button>
                <button class="tab-button" onclick="switchTab('tab-growth')">ç”Ÿé•¿æ›²çº¿</button>
                <button class="tab-button" onclick="switchTab('tab-snake')">è´ªåƒè›‡</button>
                <button class="tab-button" onclick="switchTab('tab-economy')">ç»æµç³»ç»Ÿ</button>
                <button class="tab-button" onclick="switchTab('tab-visual')">è§†è§‰é€‰é¡¹</button>
                <button class="tab-button" onclick="switchTab('tab-rules')">æ¸¸æˆè§„åˆ™</button>
            </div>
            
            <!-- åŸºç¡€ç”Ÿæ€æ ‡ç­¾é¡µ (ä¿æŒåŸæ ·) -->
            <div id="tab-basic" class="tab-content active">
                <div class="config-section">
                    <h3>åˆå§‹ç”Ÿæ€</h3>
                    <div class="config-row">
                        <div class="config-label">åˆå§‹é£Ÿç‰©æ•°é‡</div>
                        <div class="config-value">
                            <input type="range" id="cfg-startFood" min="0" max="500" step="10" value="100">
                            <input type="number" id="cfg-startFood-val" class="config-number" min="0" max="500" step="10">
                        </div>
                    </div>
                    <div class="config-row">
                        <div class="config-label">æ··ä¹±ç”Ÿå‘½ä½“æ¯”ä¾‹</div>
                        <div class="config-value">
                            <input type="range" id="cfg-chaosChance" min="0" max="100" step="1" value="30">
                            <input type="number" id="cfg-chaosChance-val" class="config-number" min="0" max="100" step="1">%
                        </div>
                    </div>
                    <div class="config-row">
                        <div class="config-label">è›‡åˆå§‹å®‰å…¨åŠå¾„</div>
                        <div class="config-value">
                            <input type="range" id="cfg-safeRadius" min="5" max="50" step="1" value="15">
                            <input type="number" id="cfg-safeRadius-val" class="config-number" min="5" max="50" step="1">æ ¼
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- ç”Ÿé•¿æ›²çº¿æ ‡ç­¾é¡µ (ä¿æŒåŸæ ·) -->
            <div id="tab-growth" class="tab-content">
                <div class="config-section">
                    <h3>é£Ÿç‰©å†ç”Ÿç³»ç»Ÿ</h3>
                    <div class="config-row">
                        <div class="config-label">å¯ç”¨è‡ªåŠ¨å†ç”Ÿ</div>
                        <div class="config-value">
                            <label class="toggle-switch">
                                <input type="checkbox" id="cfg-autoRegen" checked>
                                <span class="toggle-slider"></span>
                            </label>
                        </div>
                    </div>
                    <div class="config-row">
                        <div class="config-label">åŸºç¡€å†ç”Ÿå‡ ç‡</div>
                        <div class="config-value">
                            <input type="range" id="cfg-regenRate" min="0" max="30" step="0.5" value="5">
                            <input type="number" id="cfg-regenRate-val" class="config-number" min="0" max="30" step="0.5">%
                        </div>
                    </div>
                    <div class="config-row">
                        <div class="config-label">æ¯æ¬¡å†ç”Ÿæ•°é‡</div>
                        <div class="config-value">
                            <input type="range" id="cfg-regenAmount" min="0" max="20" step="1" value="2">
                            <input type="number" id="cfg-regenAmount-val" class="config-number" min="0" max="20" step="1">
                        </div>
                    </div>
                    <div class="config-row">
                        <div class="config-label">å†ç”Ÿéšé•¿åº¦é€’å‡</div>
                        <div class="config-value">
                            <label class="toggle-switch">
                                <input type="checkbox" id="cfg-dynamicRegen" checked>
                                <span class="toggle-slider"></span>
                            </label>
                        </div>
                    </div>
                    <div class="config-row">
                        <div class="config-label">é•¿åº¦&lt;<span id="cfg-threshold1-val">400</span>æ—¶ï¼š</div>
                        <div class="config-value">
                            <input type="range" id="cfg-threshold1" min="100" max="1000" step="50" value="400">
                            <input type="number" id="cfg-threshold1-val-display" class="config-number" min="100" max="1000" step="50">æ ¼
                        </div>
                    </div>
                    <div class="config-row">
                        <div class="config-label">å†ç”Ÿå‡ ç‡(å‰æœŸ)</div>
                        <div class="config-value">
                            <input type="range" id="cfg-rateEarly" min="0" max="50" step="1" value="15">
                            <input type="number" id="cfg-rateEarly-val" class="config-number" min="0" max="50" step="1">%
                        </div>
                    </div>
                    <div class="config-row">
                        <div class="config-label">é•¿åº¦&lt;<span id="cfg-threshold2-val">800</span>æ—¶ï¼š</div>
                        <div class="config-value">
                            <input type="range" id="cfg-threshold2" min="200" max="2000" step="50" value="800">
                            <input type="number" id="cfg-threshold2-val-display" class="config-number" min="200" max="2000" step="50">æ ¼
                        </div>
                    </div>
                    <div class="config-row">
                        <div class="config-label">å†ç”Ÿå‡ ç‡(ä¸­æœŸ)</div>
                        <div class="config-value">
                            <input type="range" id="cfg-rateMid" min="0" max="30" step="1" value="2">
                            <input type="number" id="cfg-rateMid-val" class="config-number" min="0" max="30" step="1">%
                        </div>
                    </div>
                    <div class="config-row">
                        <div class="config-label">åæœŸå†ç”Ÿå‡ ç‡</div>
                        <div class="config-value">
                            <input type="range" id="cfg-rateLate" min="0" max="10" step="0.5" value="0">
                            <input type="number" id="cfg-rateLate-val" class="config-number" min="0" max="10" step="0.5">%
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- è´ªåƒè›‡æ ‡ç­¾é¡µ (ä¿æŒåŸæ ·) -->
            <div id="tab-snake" class="tab-content">
                <div class="config-section">
                    <h3>è´ªåƒè›‡å±æ€§</h3>
                    <div class="config-row">
                        <div class="config-label">åˆå§‹é•¿åº¦</div>
                        <div class="config-value">
                            <input type="range" id="cfg-startLength" min="10" max="200" step="5" value="50">
                            <input type="number" id="cfg-startLength-val" class="config-number" min="10" max="200" step="5">
                        </div>
                    </div>
                    <div class="config-row">
                        <div class="config-label">æˆé•¿é˜ˆå€¼(æ¯<span id="cfg-growthThreshold-val">40</span>æ ¼å¢ç²—)</div>
                        <div class="config-value">
                            <input type="range" id="cfg-growthThreshold" min="20" max="200" step="10" value="40">
                            <input type="number" id="cfg-growthThreshold-val-display" class="config-number" min="20" max="200" step="10">æ ¼
                        </div>
                    </div>
                    <div class="config-row">
                        <div class="config-label">æœ€å¤§ä½“å‹å€æ•°</div>
                        <div class="config-value">
                            <input type="range" id="cfg-maxSize" min="1" max="20" step="0.5" value="10">
                            <input type="number" id="cfg-maxSize-val" class="config-number" min="1" max="20" step="0.5">å€
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- ç»æµç³»ç»Ÿæ ‡ç­¾é¡µ (ä¿æŒåŸæ ·) -->
            <div id="tab-economy" class="tab-content">
                <div class="config-section">
                    <h3>ç»æµä¸æŠ€èƒ½</h3>
                    <div class="config-row">
                        <div class="config-label">æ‰©å¤§åœ°å›¾åŸºç¡€æ¶ˆè€—</div>
                        <div class="config-value">
                            <input type="range" id="cfg-upgradeCost" min="50" max="500" step="10" value="150">
                            <input type="number" id="cfg-upgradeCost-val" class="config-number" min="50" max="500" step="10">
                        </div>
                    </div>
                    <div class="config-row">
                        <div class="config-label">æ¯æ¬¡æ‰©å¤§å¢åŠ æ¶ˆè€—</div>
                        <div class="config-value">
                            <input type="range" id="cfg-upgradeIncrement" min="10" max="200" step="10" value="50">
                            <input type="number" id="cfg-upgradeIncrement-val" class="config-number" min="10" max="200" step="10">
                        </div>
                    </div>
                    <div class="config-row">
                        <div class="config-label">æ»‘ç¿”æœºæŠ€èƒ½æ¶ˆè€—</div>
                        <div class="config-value">
                            <input type="range" id="cfg-skill1Cost" min="5" max="50" step="1" value="15">
                            <input type="number" id="cfg-skill1Cost-val" class="config-number" min="5" max="50" step="1">
                        </div>
                    </div>
                    <div class="config-row">
                        <div class="config-label">é£èˆ¹æŠ€èƒ½æ¶ˆè€—</div>
                        <div class="config-value">
                            <input type="range" id="cfg-skill2Cost" min="10" max="100" step="5" value="35">
                            <input type="number" id="cfg-skill2Cost-val" class="config-number" min="10" max="100" step="5">
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- è§†è§‰é€‰é¡¹æ ‡ç­¾é¡µ (ä¿æŒåŸæ ·) -->
            <div id="tab-visual" class="tab-content">
                <div class="config-section">
                    <h3>è§†è§‰é€‰é¡¹</h3>
                    <div class="config-row">
                        <div class="config-label">ç»†èƒå¤§å°</div>
                        <div class="config-value">
                            <input type="range" id="cfg-cellSize" min="4" max="20" step="1" value="10">
                            <input type="number" id="cfg-cellSize-val" class="config-number" min="4" max="20" step="1">px
                        </div>
                    </div>
                    <div class="config-row">
                        <div class="config-label">ç”Ÿå‘½ä½“é¢œè‰²</div>
                        <div class="config-value color-picker-container">
                            <div id="cfg-lifeColor-preview" class="color-preview" style="background:#d000d0"></div>
                            <input type="color" id="cfg-lifeColor" class="color-picker" value="#d000d0">
                        </div>
                    </div>
                    <div class="config-row">
                        <div class="config-label">è´ªåƒè›‡é¢œè‰²</div>
                        <div class="config-value color-picker-container">
                            <div id="cfg-snakeColor-preview" class="color-preview" style="background:#00cc00"></div>
                            <input type="color" id="cfg-snakeColor" class="color-picker" value="#00cc00">
                        </div>
                    </div>
                    <div class="config-row">
                        <div class="config-label">è›‡å¤´é¢œè‰²</div>
                        <div class="config-value color-picker-container">
                            <div id="cfg-snakeHeadColor-preview" class="color-preview" style="background:#ccffcc"></div>
                            <input type="color" id="cfg-snakeHeadColor" class="color-picker" value="#ccffcc">
                        </div>
                    </div>
                    <div class="config-row">
                        <div class="config-label">ç‰µå¼•å…‰æŸé¢œè‰²</div>
                        <div class="config-value color-picker-container">
                            <div id="cfg-beamColor-preview" class="color-preview" style="background:rgba(0,255,0,0.2)"></div>
                            <input type="color" id="cfg-beamColor" class="color-picker" value="#00ff00">
                        </div>
                    </div>
                    <div class="config-row">
                        <div class="config-label">æ˜¾ç¤ºç½‘æ ¼çº¿</div>
                        <div class="config-value">
                            <label class="toggle-switch">
                                <input type="checkbox" id="cfg-showGrid" checked>
                                <span class="toggle-slider"></span>
                            </label>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- æ¸¸æˆè§„åˆ™æ ‡ç­¾é¡µ (æ–°å¢!) -->
            <div id="tab-rules" class="tab-content">
                <div class="config-section">
                    <h3>åº·å¨ç”Ÿå‘½æ¸¸æˆè§„åˆ™</h3>
                    
                    <div class="rules-container">
                        <div class="rules-input">
                            <div class="rule-input-group">
                                <label for="cfg-ruleBirth">å‡ºç”Ÿè§„åˆ™ (B...)</label>
                                <input type="text" id="cfg-ruleBirth" class="rule-text-input" value="3" placeholder="ä¾‹å¦‚: 3 æˆ– 3,6">
                                <small style="color:#888">æ­»ç»†èƒåœ¨å…·æœ‰è¿™äº›æ•°é‡çš„æ´»é‚»å±…æ—¶å‡ºç”Ÿ</small>
                            </div>
                            
                            <div class="rule-input-group">
                                <label for="cfg-ruleSurvive">å­˜æ´»è§„åˆ™ (S...)</label>
                                <input type="text" id="cfg-ruleSurvive" class="rule-text-input" value="2,3" placeholder="ä¾‹å¦‚: 2,3 æˆ– 2,3,4">
                                <small style="color:#888">æ´»ç»†èƒåœ¨å…·æœ‰è¿™äº›æ•°é‡çš„æ´»é‚»å±…æ—¶å­˜æ´»</small>
                            </div>
                            
                            <div style="margin-top:15px; padding:10px; background:#1a1a1a; border-radius:4px;">
                                <strong>å½“å‰è§„åˆ™: </strong><span id="current-rule-display">B3/S23</span>
                                <div style="margin-top:5px; font-size:12px; color:#aaa">
                                    æ ‡å‡†è§„åˆ™: æ­»ç»†èƒæœ‰3ä¸ªæ´»é‚»å±…æ—¶å‡ºç”Ÿï¼Œæ´»ç»†èƒæœ‰2æˆ–3ä¸ªæ´»é‚»å±…æ—¶å­˜æ´»
                                </div>
                            </div>
                        </div>
                        
                        <div class="rules-visual">
                            <div class="rules-grid">
                                <div class="rules-row">
                                    <div class="rules-title">å‡ºç”Ÿ (B)</div>
                                    <div class="rules-cells" id="birth-cells">
                                        <div class="rule-cell birth" data-num="0">0</div>
                                        <div class="rule-cell birth" data-num="1">1</div>
                                        <div class="rule-cell birth" data-num="2">2</div>
                                        <div class="rule-cell birth" data-num="3">3</div>
                                        <div class="rule-cell birth" data-num="4">4</div>
                                        <div class="rule-cell birth" data-num="5">5</div>
                                        <div class="rule-cell birth" data-num="6">6</div>
                                        <div class="rule-cell birth" data-num="7">7</div>
                                        <div class="rule-cell birth" data-num="8">8</div>
                                    </div>
                                </div>
                                <div class="rules-row">
                                    <div class="rules-title">å­˜æ´» (S)</div>
                                    <div class="rules-cells" id="survive-cells">
                                        <div class="rule-cell survive" data-num="0">0</div>
                                        <div class="rule-cell survive" data-num="1">1</div>
                                        <div class="rule-cell survive" data-num="2">2</div>
                                        <div class="rule-cell survive" data-num="3">3</div>
                                        <div class="rule-cell survive" data-num="4">4</div>
                                        <div class="rule-cell survive" data-num="5">5</div>
                                        <div class="rule-cell survive" data-num="6">6</div>
                                        <div class="rule-cell survive" data-num="7">7</div>
                                        <div class="rule-cell survive" data-num="8">8</div>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="rules-preview">
                                <h4>è§„åˆ™é¢„è§ˆ</h4>
                                <canvas id="rules-preview-canvas" class="preview-canvas" width="200" height="100"></canvas>
                                <div style="margin-top:10px; font-size:12px; color:#aaa">
                                    å±•ç¤ºéšæœºåˆå§‹çŠ¶æ€åœ¨10ä»£åçš„æ¼”åŒ–
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <h4 style="margin-top:30px;">é¢„è®¾è§„åˆ™</h4>
                    <div class="rule-presets">
                        <div class="rule-preset" data-rule="B3/S23">åº·å¨ç”Ÿå‘½æ¸¸æˆ</div>
                        <div class="rule-preset" data-rule="B36/S23">é«˜ç”Ÿå‘½ (HighLife)</div>
                        <div class="rule-preset" data-rule="B3678/S34678">æ—¥ä¸å¤œ (Day & Night)</div>
                        <div class="rule-preset" data-rule="B2/S">ç”Ÿå‘½ç§å­ (Seeds)</div>
                        <div class="rule-preset" data-rule="B3/S012345678">ç”Ÿå‘½è¿·å®« (Maze)</div>
                        <div class="rule-preset" data-rule="B1357/S1357">å¤åˆ¶æœº (Replicator)</div>
                        <div class="rule-preset" data-rule="B36/S125">2x2</div>
                        <div class="rule-preset" data-rule="B34/S34">34ç”Ÿå‘½ (34 Life)</div>
                        <div class="rule-preset" data-rule="B1/S012345678">æ‰©æ•£ (Diffusion)</div>
                        <div class="rule-preset" data-rule="B5678/S45678">çŠç‘š (Coral)</div>
                        <div class="rule-preset" data-rule="B3/S1234">æœ‰ä¸åˆ†è£‚ (Mitosis)</div>
                        <div class="rule-preset" data-rule="B3/S0">çˆ†ç‚¸ (Explosion)</div>
                    </div>
                </div>
            </div>
            
            <div style="display:flex; gap:10px; margin-top:30px;">
                <button onclick="saveCustomConfig()" style="flex:1; background:#224400; color:#88ff00; padding:12px; font-size:16px">
                    ä¿å­˜å¹¶å¼€å§‹
                </button>
                <button onclick="loadDefaultConfig()" style="background:#333; padding:12px">
                    é‡ç½®é»˜è®¤
                </button>
                <button onclick="showStartMenu()" style="background:#333; padding:12px">
                    è¿”å›
                </button>
            </div>
        </div>
    </div>
    
    <!-- æ¸¸æˆç»“æŸç•Œé¢ -->
    <div id="game-over-modal" class="modal-overlay" style="display:none">
        <div class="modal-box" style="border-color:#500">
            <h1 style="color:#f44; margin:0 0 20px 0">å­˜æ´»å¤±è´¥</h1>
            <p id="death-reason" style="color:#ccc; margin-bottom:20px"></p>
            <p>æœ€ç»ˆé•¿åº¦: <span id="final-len" class="val"></span></p>
            <button class="mode-select-btn" style="background:#ddd; color:#000; text-align:center; margin-top:20px" onclick="showStartMenu()">é‡æ–°é€‰æ‹©</button>
        </div>
    </div>

<script>
// --- æ ¸å¿ƒå·¥å…·ï¼šå®‰å…¨å–æ¨¡ ---
function safeMod(n, m) {
    return ((n % m) + m) % m;
}

// --- éŸ³æ•ˆç³»ç»Ÿ ---
const Sound = {
    ctx: null, muted: false,
    init: function() { 
        if (this.ctx) return;
        try { 
            this.ctx = new (window.AudioContext || window.webkitAudioContext)(); 
        } catch(e) { 
            console.warn("AudioContext init failed:", e); 
            this.ctx = null;
        }
    },
    playEat: function() {
        if (this.muted || !this.ctx) return;
        if (this.ctx.state === 'suspended') this.ctx.resume().catch(() => {});
        try {
            const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain();
            osc.connect(gain); gain.connect(this.ctx.destination);
            osc.type = 'sine';
            osc.frequency.setValueAtTime(400 + Math.random() * 200, this.ctx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(800, this.ctx.currentTime + 0.1);
            gain.gain.setValueAtTime(0.08, this.ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.1);
            osc.start(); osc.stop(this.ctx.currentTime + 0.1);
        } catch(e) { console.warn("Sound play error:", e); }
    },
    playDie: function() {
        if (this.muted || !this.ctx) return;
        try {
            const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain();
            osc.connect(gain); gain.connect(this.ctx.destination);
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(150, this.ctx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(40, this.ctx.currentTime + 0.5);
            gain.gain.setValueAtTime(0.2, this.ctx.currentTime);
            gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.5);
            osc.start(); osc.stop(this.ctx.currentTime + 0.5);
        } catch(e) { console.warn("Die sound error:", e); }
    }
};

// --- é¢„è®¾æ¨¡å¼ ---
const MODES = {
    flood: { 
        name: "ä¸°é¥¶ä¹‹æµ·", className: "mode-flood", 
        regenRateBase: 0.15, regenAmount: 3, chaosChance: 0.02, 
        startFood: 180, safeRadius: 20,
        startLength: 50, growthThreshold: 40, maxSize: 10,
        upgradeCostBase: 150, upgradeCostIncrement: 50,
        skill1Cost: 15, skill2Cost: 35,
        cellSize: 10,
        lifeColor: '#d000d0', snakeColor: '#00cc00', snakeHeadColor: '#ccffcc', beamColor: 'rgba(0,255,0,0.2)',
        showGrid: true,
        dynamicRegen: true, regenRates: [0.15, 0.02, 0], thresholds: [400, 800],
        // è§„åˆ™ç³»ç»Ÿ
        birthRules: [3], surviveRules: [2, 3]
    },
    drought: { 
        name: "è’èŠœåºŸåœŸ", className: "mode-drought", 
        regenRateBase: 0, regenAmount: 0, chaosChance: 0.05, 
        startFood: 40, safeRadius: 10,
        startLength: 50, growthThreshold: 40, maxSize: 10,
        upgradeCostBase: 150, upgradeCostIncrement: 50,
        skill1Cost: 15, skill2Cost: 35,
        cellSize: 10,
        lifeColor: '#d000d0', snakeColor: '#00cc00', snakeHeadColor: '#ccffcc', beamColor: 'rgba(0,255,0,0.2)',
        showGrid: true,
        dynamicRegen: false, regenRates: [0, 0, 0], thresholds: [400, 800],
        birthRules: [3], surviveRules: [2, 3]
    },
    dark: { 
        name: "é»‘æš—æ£®æ—", className: "mode-dark", 
        regenRateBase: 0.02, regenAmount: 1, chaosChance: 0.6, 
        startFood: 80, safeRadius: 15,
        startLength: 50, growthThreshold: 40, maxSize: 10,
        upgradeCostBase: 150, upgradeCostIncrement: 50,
        skill1Cost: 15, skill2Cost: 35,
        cellSize: 10,
        lifeColor: '#d000d0', snakeColor: '#00cc00', snakeHeadColor: '#ccffcc', beamColor: 'rgba(0,255,0,0.2)',
        showGrid: true,
        dynamicRegen: false, regenRates: [0.02, 0.02, 0.02], thresholds: [400, 800],
        birthRules: [3], surviveRules: [2, 3]
    },
    custom: {
        name: "è‡ªå®šä¹‰", className: "mode-custom",
        // è¿™äº›å€¼å°†åœ¨è‡ªå®šä¹‰é…ç½®ä¸­å¡«å……
        regenRateBase: 0.05, regenAmount: 2, chaosChance: 0.3,
        startFood: 100, safeRadius: 15,
        startLength: 50, growthThreshold: 40, maxSize: 10,
        upgradeCostBase: 150, upgradeCostIncrement: 50,
        skill1Cost: 15, skill2Cost: 35,
        cellSize: 10,
        lifeColor: '#d000d0', snakeColor: '#00cc00', snakeHeadColor: '#ccffcc', beamColor: 'rgba(0,255,0,0.2)',
        showGrid: true,
        dynamicRegen: true, regenRates: [0.15, 0.02, 0], thresholds: [400, 800],
        birthRules: [3], surviveRules: [2, 3]
    }
};

// --- æ¸¸æˆçŠ¶æ€ ---
const state = {
    mode: 'custom', w: 150, h: 100,
    grid: null, nextGrid: null,
    snake: { path: [], dir: {x:1, y:0}, length: 50, radius: 1.0 },
    upgradeCost: 150, growing: 0, lifeRunning: true, gameOver: false, needsRender: true,
    lifeInterval: null, mouseInterval: null, 
    mouse: { active: false, x: 0, y: 0 },
    camera: { x: 0, y: 0, zoom: 1.0 },
    controlMode: 'direct', rtsTarget: null, rtsPathTimer: null,
    config: null // å­˜å‚¨å½“å‰ä½¿ç”¨çš„é…ç½®
};

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d', { alpha: true, willReadFrequently: false });
const elMode = document.getElementById('current-mode-badge');
const elCtrlMode = document.getElementById('ctrl-mode');
const elLen = document.getElementById('len-val');
const elMap = document.getElementById('map-val');
const elZoom = document.getElementById('zoom-val');
const btnUpgrade = document.getElementById('btn-upgrade');
const btnPause = document.getElementById('btn-pause');
const btnMute = document.getElementById('btn-mute');
const startModal = document.getElementById('start-modal');
const customModal = document.getElementById('custom-modal');
const overModal = document.getElementById('game-over-modal');

// --- è§„åˆ™é¢„è§ˆç³»ç»Ÿ ---
const rulesPreview = {
    canvas: document.getElementById('rules-preview-canvas'),
    ctx: null,
    grid: null,
    nextGrid: null,
    width: 20,
    height: 10,
    init: function() {
        this.ctx = this.canvas.getContext('2d');
        this.grid = this.createGrid(this.width, this.height);
        this.nextGrid = this.createGrid(this.width, this.height);
        
        // åˆå§‹åŒ–éšæœºçŠ¶æ€
        for (let x = 0; x < this.width; x++) {
            for (let y = 0; y < this.height; y++) {
                this.grid[x][y] = Math.random() < 0.3 ? 1 : 0;
            }
        }
    },
    createGrid: function(w, h) {
        let g = new Array(w);
        for(let i = 0; i < w; i++) g[i] = new Uint8Array(h);
        return g;
    },
    update: function(birthRules, surviveRules) {
        // åº”ç”¨è§„åˆ™æ¼”åŒ–ä¸€ä»£
        for (let x = 0; x < this.width; x++) {
            for (let y = 0; y < this.height; y++) {
                let n = 0;
                for (let dx = -1; dx <= 1; dx++) {
                    for (let dy = -1; dy <= 1; dy++) {
                        if (dx === 0 && dy === 0) continue;
                        let nx = (x + dx + this.width) % this.width;
                        let ny = (y + dy + this.height) % this.height;
                        n += this.grid[nx][ny];
                    }
                }
                
                let c = this.grid[x][y];
                if (c === 0) {
                    // æ­»ç»†èƒï¼šæ£€æŸ¥å‡ºç”Ÿè§„åˆ™
                    this.nextGrid[x][y] = birthRules.includes(n) ? 1 : 0;
                } else {
                    // æ´»ç»†èƒï¼šæ£€æŸ¥å­˜æ´»è§„åˆ™
                    this.nextGrid[x][y] = surviveRules.includes(n) ? 1 : 0;
                }
            }
        }
        
        // äº¤æ¢ç½‘æ ¼
        let temp = this.grid;
        this.grid = this.nextGrid;
        this.nextGrid = temp;
    },
    draw: function() {
        this.ctx.fillStyle = '#000';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        const cellSize = this.canvas.width / this.width;
        
        this.ctx.fillStyle = '#0f0';
        for (let x = 0; x < this.width; x++) {
            for (let y = 0; y < this.height; y++) {
                if (this.grid[x][y] === 1) {
                    this.ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
                }
            }
        }
        
        // ç»˜åˆ¶ç½‘æ ¼çº¿
        this.ctx.strokeStyle = '#333';
        this.ctx.lineWidth = 0.5;
        for (let x = 0; x <= this.width; x++) {
            this.ctx.beginPath();
            this.ctx.moveTo(x * cellSize, 0);
            this.ctx.lineTo(x * cellSize, this.canvas.height);
            this.ctx.stroke();
        }
        for (let y = 0; y <= this.height; y++) {
            this.ctx.beginPath();
            this.ctx.moveTo(0, y * cellSize);
            this.ctx.lineTo(this.canvas.width, y * cellSize);
            this.ctx.stroke();
        }
    },
    runPreview: function(birthRules, surviveRules) {
        // é‡ç½®ä¸ºéšæœºçŠ¶æ€
        for (let x = 0; x < this.width; x++) {
            for (let y = 0; y < this.height; y++) {
                this.grid[x][y] = Math.random() < 0.3 ? 1 : 0;
            }
        }
        
        // æ¼”åŒ–10ä»£
        for (let i = 0; i < 10; i++) {
            this.update(birthRules, surviveRules);
        }
        
        this.draw();
    }
};

// åˆå§‹åŒ–è§„åˆ™é¢„è§ˆ
rulesPreview.init();

// --- è§„åˆ™ç®¡ç†å‡½æ•° ---
function parseRuleString(ruleStr) {
    // å°†ç±»ä¼¼ "3" æˆ– "2,3" çš„å­—ç¬¦ä¸²è½¬æ¢ä¸ºæ•°å­—æ•°ç»„
    if (!ruleStr || ruleStr.trim() === '') return [];
    return ruleStr.split(',').map(s => parseInt(s.trim())).filter(n => !isNaN(n));
}

function updateRuleDisplay() {
    const birthStr = document.getElementById('cfg-ruleBirth').value;
    const surviveStr = document.getElementById('cfg-ruleSurvive').value;
    
    const birthRules = parseRuleString(birthStr);
    const surviveRules = parseRuleString(surviveStr);
    
    // æ›´æ–°æ˜¾ç¤º
    document.getElementById('current-rule-display').textContent = 
        `B${birthRules.sort((a,b) => a-b).join('')}/S${surviveRules.sort((a,b) => a-b).join('')}`;
    
    // æ›´æ–°å¯è§†åŒ–ç½‘æ ¼
    updateRuleVisualization(birthRules, surviveRules);
    
    // è¿è¡Œé¢„è§ˆ
    rulesPreview.runPreview(birthRules, surviveRules);
}

function updateRuleVisualization(birthRules, surviveRules) {
    // æ›´æ–°å‡ºç”Ÿè§„åˆ™å•å…ƒæ ¼
    document.querySelectorAll('#birth-cells .rule-cell').forEach(cell => {
        const num = parseInt(cell.getAttribute('data-num'));
        if (birthRules.includes(num)) {
            cell.classList.add('active');
        } else {
            cell.classList.remove('active');
        }
    });
    
    // æ›´æ–°å­˜æ´»è§„åˆ™å•å…ƒæ ¼
    document.querySelectorAll('#survive-cells .rule-cell').forEach(cell => {
        const num = parseInt(cell.getAttribute('data-num'));
        if (surviveRules.includes(num)) {
            cell.classList.add('active');
        } else {
            cell.classList.remove('active');
        }
    });
}

function applyPresetRule(ruleString) {
    // è§£æ B.../S... æ ¼å¼çš„è§„åˆ™å­—ç¬¦ä¸²
    const match = ruleString.match(/B([0-8,]*)\/S([0-8,]*)/);
    if (!match) return;
    
    const birthPart = match[1];
    const survivePart = match[2];
    
    // è½¬æ¢ä¸ºé€—å·åˆ†éš”æ ¼å¼
    const birthStr = birthPart.split('').join(',');
    const surviveStr = survivePart.split('').join(',');
    
    // æ›´æ–°è¾“å…¥æ¡†
    document.getElementById('cfg-ruleBirth').value = birthStr;
    document.getElementById('cfg-ruleSurvive').value = surviveStr;
    
    // æ›´æ–°æ˜¾ç¤º
    updateRuleDisplay();
    
    // æ¿€æ´»å¯¹åº”çš„é¢„è®¾æŒ‰é’®
    document.querySelectorAll('.rule-preset').forEach(btn => {
        if (btn.getAttribute('data-rule') === ruleString) {
            btn.classList.add('active');
        } else {
            btn.classList.remove('active');
        }
    });
}

// --- é…ç½®ç®¡ç† ---
function saveCustomConfig() {
    const config = {
        // åŸºç¡€ç”Ÿæ€
        startFood: parseInt(document.getElementById('cfg-startFood').value),
        chaosChance: parseInt(document.getElementById('cfg-chaosChance').value) / 100,
        safeRadius: parseInt(document.getElementById('cfg-safeRadius').value),
        
        // ç”Ÿé•¿æ›²çº¿
        autoRegen: document.getElementById('cfg-autoRegen').checked,
        regenRateBase: parseFloat(document.getElementById('cfg-regenRate').value) / 100,
        regenAmount: parseInt(document.getElementById('cfg-regenAmount').value),
        dynamicRegen: document.getElementById('cfg-dynamicRegen').checked,
        thresholds: [
            parseInt(document.getElementById('cfg-threshold1').value),
            parseInt(document.getElementById('cfg-threshold2').value)
        ],
        regenRates: [
            parseFloat(document.getElementById('cfg-rateEarly').value) / 100,
            parseFloat(document.getElementById('cfg-rateMid').value) / 100,
            parseFloat(document.getElementById('cfg-rateLate').value) / 100
        ],
        
        // è´ªåƒè›‡
        startLength: parseInt(document.getElementById('cfg-startLength').value),
        growthThreshold: parseInt(document.getElementById('cfg-growthThreshold').value),
        maxSize: parseFloat(document.getElementById('cfg-maxSize').value),
        
        // ç»æµç³»ç»Ÿ
        upgradeCostBase: parseInt(document.getElementById('cfg-upgradeCost').value),
        upgradeCostIncrement: parseInt(document.getElementById('cfg-upgradeIncrement').value),
        skill1Cost: parseInt(document.getElementById('cfg-skill1Cost').value),
        skill2Cost: parseInt(document.getElementById('cfg-skill2Cost').value),
        
        // è§†è§‰é€‰é¡¹
        cellSize: parseInt(document.getElementById('cfg-cellSize').value),
        lifeColor: document.getElementById('cfg-lifeColor').value,
        snakeColor: document.getElementById('cfg-snakeColor').value,
        snakeHeadColor: document.getElementById('cfg-snakeHeadColor').value,
        beamColor: hexToRgba(document.getElementById('cfg-beamColor').value, 0.2),
        showGrid: document.getElementById('cfg-showGrid').checked,
        
        // æ¸¸æˆè§„åˆ™ (æ–°å¢!)
        birthRules: parseRuleString(document.getElementById('cfg-ruleBirth').value),
        surviveRules: parseRuleString(document.getElementById('cfg-ruleSurvive').value)
    };
    
    // ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨
    localStorage.setItem('snakeOfLife_customConfig', JSON.stringify(config));
    
    // æ›´æ–°è‡ªå®šä¹‰æ¨¡å¼é…ç½®
    MODES.custom = { ...MODES.custom, ...config };
    
    // å¼€å§‹æ¸¸æˆ
    customModal.style.display = 'none';
    startGame('custom');
}

function hexToRgba(hex, alpha) {
    if (hex.startsWith('rgba')) return hex;
    
    const r = parseInt(hex.slice(1, 3), 16);
    const g = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);
    return `rgba(${r}, ${g}, ${b}, ${alpha})`;
}

function loadCustomConfig() {
    const saved = localStorage.getItem('snakeOfLife_customConfig');
    if (!saved) return;
    
    const config = JSON.parse(saved);
    
    // æ›´æ–°æ‰€æœ‰è¡¨å•å…ƒç´ 
    document.getElementById('cfg-startFood').value = config.startFood;
    document.getElementById('cfg-chaosChance').value = Math.round(config.chaosChance * 100);
    document.getElementById('cfg-safeRadius').value = config.safeRadius;
    
    document.getElementById('cfg-autoRegen').checked = config.autoRegen;
    document.getElementById('cfg-regenRate').value = Math.round(config.regenRateBase * 100);
    document.getElementById('cfg-regenAmount').value = config.regenAmount;
    document.getElementById('cfg-dynamicRegen').checked = config.dynamicRegen;
    document.getElementById('cfg-threshold1').value = config.thresholds[0];
    document.getElementById('cfg-threshold2').value = config.thresholds[1];
    document.getElementById('cfg-rateEarly').value = Math.round(config.regenRates[0] * 100);
    document.getElementById('cfg-rateMid').value = Math.round(config.regenRates[1] * 100);
    document.getElementById('cfg-rateLate').value = Math.round(config.regenRates[2] * 100);
    
    document.getElementById('cfg-startLength').value = config.startLength;
    document.getElementById('cfg-growthThreshold').value = config.growthThreshold;
    document.getElementById('cfg-maxSize').value = config.maxSize;
    
    document.getElementById('cfg-upgradeCost').value = config.upgradeCostBase;
    document.getElementById('cfg-upgradeIncrement').value = config.upgradeCostIncrement;
    document.getElementById('cfg-skill1Cost').value = config.skill1Cost;
    document.getElementById('cfg-skill2Cost').value = config.skill2Cost;
    
    document.getElementById('cfg-cellSize').value = config.cellSize;
    document.getElementById('cfg-lifeColor').value = config.lifeColor;
    document.getElementById('cfg-snakeColor').value = config.snakeColor;
    document.getElementById('cfg-snakeHeadColor').value = config.snakeHeadColor;
    const beamHex = config.beamColor.replace(/rgba\((\d+),\s*(\d+),\s*(\d+),\s*[\d.]+\)/, '#$1$2$3'.replace(/(\d+)/g, (m, n) => parseInt(n).toString(16).padStart(2, '0')));
    document.getElementById('cfg-beamColor').value = beamHex;
    document.getElementById('cfg-showGrid').checked = config.showGrid;
    
    // æ›´æ–°è§„åˆ™ (æ–°å¢!)
    if (config.birthRules && config.surviveRules) {
        document.getElementById('cfg-ruleBirth').value = config.birthRules.join(',');
        document.getElementById('cfg-ruleSurvive').value = config.surviveRules.join(',');
    }
    
    // æ›´æ–°é¢„è§ˆ
    updateColorPreviews();
    updateAllValues();
    updateRuleDisplay();
}

function loadDefaultConfig() {
    // é‡ç½®ä¸ºä¸°é¥¶ä¹‹æµ·çš„é…ç½®
    const defaultConfig = MODES.flood;
    
    document.getElementById('cfg-startFood').value = defaultConfig.startFood;
    document.getElementById('cfg-chaosChance').value = Math.round(defaultConfig.chaosChance * 100);
    document.getElementById('cfg-safeRadius').value = defaultConfig.safeRadius;
    
    document.getElementById('cfg-autoRegen').checked = true;
    document.getElementById('cfg-regenRate').value = Math.round(defaultConfig.regenRateBase * 100);
    document.getElementById('cfg-regenAmount').value = defaultConfig.regenAmount;
    document.getElementById('cfg-dynamicRegen').checked = defaultConfig.dynamicRegen;
    document.getElementById('cfg-threshold1').value = defaultConfig.thresholds[0];
    document.getElementById('cfg-threshold2').value = defaultConfig.thresholds[1];
    document.getElementById('cfg-rateEarly').value = Math.round(defaultConfig.regenRates[0] * 100);
    document.getElementById('cfg-rateMid').value = Math.round(defaultConfig.regenRates[1] * 100);
    document.getElementById('cfg-rateLate').value = Math.round(defaultConfig.regenRates[2] * 100);
    
    document.getElementById('cfg-startLength').value = defaultConfig.startLength;
    document.getElementById('cfg-growthThreshold').value = defaultConfig.growthThreshold;
    document.getElementById('cfg-maxSize').value = defaultConfig.maxSize;
    
    document.getElementById('cfg-upgradeCost').value = defaultConfig.upgradeCostBase;
    document.getElementById('cfg-upgradeIncrement').value = defaultConfig.upgradeCostIncrement;
    document.getElementById('cfg-skill1Cost').value = defaultConfig.skill1Cost;
    document.getElementById('cfg-skill2Cost').value = defaultConfig.skill2Cost;
    
    document.getElementById('cfg-cellSize').value = defaultConfig.cellSize;
    document.getElementById('cfg-lifeColor').value = defaultConfig.lifeColor;
    document.getElementById('cfg-snakeColor').value = defaultConfig.snakeColor;
    document.getElementById('cfg-snakeHeadColor').value = defaultConfig.snakeHeadColor;
    const beamHex = defaultConfig.beamColor.replace(/rgba\((\d+),\s*(\d+),\s*(\d+),\s*[\d.]+\)/, '#$1$2$3'.replace(/(\d+)/g, (m, n) => parseInt(n).toString(16).padStart(2, '0')));
    document.getElementById('cfg-beamColor').value = beamHex;
    document.getElementById('cfg-showGrid').checked = defaultConfig.showGrid;
    
    // è§„åˆ™é‡ç½®ä¸ºæ ‡å‡†è§„åˆ™
    document.getElementById('cfg-ruleBirth').value = defaultConfig.birthRules.join(',');
    document.getElementById('cfg-ruleSurvive').value = defaultConfig.surviveRules.join(',');
    
    updateColorPreviews();
    updateAllValues();
    updateRuleDisplay();
}

function updateColorPreviews() {
    document.getElementById('cfg-lifeColor-preview').style.background = document.getElementById('cfg-lifeColor').value;
    document.getElementById('cfg-snakeColor-preview').style.background = document.getElementById('cfg-snakeColor').value;
    document.getElementById('cfg-snakeHeadColor-preview').style.background = document.getElementById('cfg-snakeHeadColor').value;
    document.getElementById('cfg-beamColor-preview').style.background = hexToRgba(document.getElementById('cfg-beamColor').value, 0.2);
}

function updateAllValues() {
    // æ›´æ–°æ‰€æœ‰æ•°å€¼æ˜¾ç¤º
    const updateValue = (sliderId, valueId, suffix = '') => {
        const slider = document.getElementById(sliderId);
        const value = slider.value;
        const display = document.getElementById(valueId);
        if (display) display.textContent = value + suffix;
        const input = document.getElementById(valueId + '-val');
        if (input) input.value = value;
    };
    
    updateValue('cfg-startFood', 'cfg-startFood-val');
    updateValue('cfg-chaosChance', 'cfg-chaosChance-val', '%');
    updateValue('cfg-safeRadius', 'cfg-safeRadius-val', 'æ ¼');
    
    updateValue('cfg-regenRate', 'cfg-regenRate-val', '%');
    updateValue('cfg-regenAmount', 'cfg-regenAmount-val');
    
    updateValue('cfg-threshold1', 'cfg-threshold1-val');
    updateValue('cfg-threshold2', 'cfg-threshold2-val');
    updateValue('cfg-rateEarly', 'cfg-rateEarly-val', '%');
    updateValue('cfg-rateMid', 'cfg-rateMid-val', '%');
    updateValue('cfg-rateLate', 'cfg-rateLate-val', '%');
    
    updateValue('cfg-startLength', 'cfg-startLength-val');
    updateValue('cfg-growthThreshold', 'cfg-growthThreshold-val');
    updateValue('cfg-maxSize', 'cfg-maxSize-val', 'å€');
    
    updateValue('cfg-upgradeCost', 'cfg-upgradeCost-val');
    updateValue('cfg-upgradeIncrement', 'cfg-upgradeIncrement-val');
    updateValue('cfg-skill1Cost', 'cfg-skill1Cost-val');
    updateValue('cfg-skill2Cost', 'cfg-skill2Cost-val');
    
    updateValue('cfg-cellSize', 'cfg-cellSize-val', 'px');
}

// --- ç•Œé¢æ§åˆ¶ ---
function showCustomConfig() {
    startModal.style.display = 'none';
    customModal.style.display = 'flex';
    loadCustomConfig(); // åŠ è½½å·²ä¿å­˜çš„é…ç½®
}

function switchTab(tabName) {
    // éšè—æ‰€æœ‰æ ‡ç­¾é¡µ
    document.querySelectorAll('.tab-content').forEach(tab => {
        tab.classList.remove('active');
    });
    
    // ç§»é™¤æ‰€æœ‰æ ‡ç­¾æŒ‰é’®çš„æ¿€æ´»çŠ¶æ€
    document.querySelectorAll('.tab-button').forEach(btn => {
        btn.classList.remove('active');
    });
    
    // æ˜¾ç¤ºé€‰ä¸­çš„æ ‡ç­¾é¡µ
    document.getElementById(tabName).classList.add('active');
    
    // æ¿€æ´»å¯¹åº”çš„æŒ‰é’®
    event.target.classList.add('active');
}

// --- æ¸¸æˆæ ¸å¿ƒé€»è¾‘ (ä¿®æ”¹äº†updateLifeä»¥ä½¿ç”¨è‡ªå®šä¹‰è§„åˆ™) ---
window.addEventListener('resize', resizeCanvas);
canvas.oncontextmenu = function(e) { e.preventDefault(); return false; };

function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }

canvas.addEventListener('wheel', (e) => {
    e.preventDefault();
    if(!state.grid) return;
    
    const oldZoom = state.camera.zoom;
    const delta = e.deltaY > 0 ? 0.9 : 1.1;
    let newZoom = clamp(oldZoom * delta, 0.4, 2.5);

    const centerX = Math.floor(canvas.width / 2);
    const centerY = Math.floor(canvas.height / 2);
    const worldCenterX = Math.floor((state.camera.x + centerX / oldZoom) / state.config.cellSize) * state.config.cellSize;
    const worldCenterY = Math.floor((state.camera.y + centerY / oldZoom) / state.config.cellSize) * state.config.cellSize;

    state.camera.zoom = newZoom;
    state.camera.x = Math.floor(worldCenterX - centerX / newZoom);
    state.camera.y = Math.floor(worldCenterY - centerY / newZoom);
    
    updateUI(); state.needsRender = true;
}, { passive: false });

function resizeCanvas() {
    canvas.width = window.innerWidth; canvas.height = window.innerHeight;
    ctx.resetTransform();
    state.needsRender = true;
}

function showStartMenu() {
    state.gameOver = true; stopMouseLoop();
    state.mouse.active = false; state.rtsTarget = null;
    if(state.lifeInterval) clearInterval(state.lifeInterval);
    overModal.style.display = 'none'; startModal.style.display = 'flex';
}

function startGame(modeKey) {
    setTimeout(() => Sound.init(), 100);
    state.mode = modeKey;
    const mode = MODES[modeKey];
    elMode.innerText = mode.name; elMode.className = "mode-badge " + mode.className;
    startModal.style.display = 'none'; customModal.style.display = 'none';
    overModal.style.display = 'none';
    
    // å­˜å‚¨å½“å‰é…ç½®
    state.config = mode;
    
    state.gameOver = false; state.lifeRunning = true; state.growing = 0;
    state.w = 150; state.h = 100;
    state.upgradeCost = mode.upgradeCostBase;
    state.mouse.active = false; state.camera.zoom = 1.0; state.camera.x = 0; state.camera.y = 0;
    state.controlMode = 'direct'; state.rtsTarget = null;
    updateCtrlModeUI();
    
    resizeCanvas();
    state.grid = createGrid(state.w, state.h);
    state.nextGrid = createGrid(state.w, state.h);
    
    const cx = Math.floor(state.w / 2); const cy = Math.floor(state.h / 2);
    state.snake.length = mode.startLength; state.snake.radius = 1.0;
    state.snake.path = []; state.snake.dir = {x:1, y:0};
    for(let i=0; i<state.snake.length; i++) state.snake.path.push({x: cx - i, y: cy});
    updateSnakeSize();

    centerCameraImmediate();
    spawnFood(mode.startFood);
    if(state.lifeInterval) clearInterval(state.lifeInterval);
    state.lifeInterval = setInterval(updateLife, 150);
    
    stopMouseLoop(); updateUI(); state.needsRender = true; requestAnimationFrame(renderLoop);
}

function centerCameraImmediate() {
    if(state.snake.path.length === 0) return;
    const head = state.snake.path[0];
    state.camera.x = Math.floor(head.x * state.config.cellSize - (canvas.width / state.camera.zoom) / 2);
    state.camera.y = Math.floor(head.y * state.config.cellSize - (canvas.height / state.camera.zoom) / 2);
}

function createGrid(w, h) { let g = new Array(w); for(let i=0; i<w; i++) g[i] = new Uint8Array(h); return g; }

function safeSet(x, y, v) { 
    const sx = safeMod(x, state.w); const sy = safeMod(y, state.h);
    if (sx >= 0 && sx < state.w && sy >= 0 && sy < state.h) state.grid[sx][sy] = v; 
}

function spawnFood(count) {
    if(!state.grid) return;
    const mode = state.config;
    let spawned = 0; let attempts = 0;
    while(spawned < count && attempts < count * 20) {
        attempts++;
        let x = Math.random() * state.w | 0; let y = Math.random() * state.h | 0;
        if (!isLocationSafe(x, y, mode.safeRadius)) continue;
        spawned++;
        if(Math.random() < mode.chaosChance) {
            let shape = [{x:1,y:0}, {x:2,y:0}, {x:0,y:1}, {x:1,y:1}, {x:1,y:2}];
            shape.forEach(p => safeSet(x+p.x, y+p.y, 1));
        } else {
            safeSet(x, y, 1); safeSet(x+1, y, 1); safeSet(x, y+1, 1); safeSet(x+1, y+1, 1);
        }
    }
}

function isLocationSafe(x, y, radius) {
    const cx = state.w / 2; const cy = state.h / 2;
    if (state.snake.path.length === 0) return (x-cx)**2 + (y-cy)**2 >= 60*60;
    const safeSq = radius * radius;
    for (let i = 0; i < state.snake.path.length; i+=5) {
        let p = state.snake.path[i];
        let dx = Math.abs(x - p.x); let dy = Math.abs(y - p.y);
        if (dx > state.w / 2) dx = state.w - dx; if (dy > state.h / 2) dy = state.h - dy;
        if (dx*dx + dy*dy < safeSq) return false;
    }
    return true;
}

// --- ä¿®æ”¹çš„æ ¸å¿ƒï¼šä½¿ç”¨è‡ªå®šä¹‰è§„åˆ™çš„updateLife ---
function updateLife() {
    if(state.gameOver || !state.lifeRunning || !state.grid) return;
    const w = state.w; const h = state.h;
    const mode = state.config;
    
    // è·å–å½“å‰è§„åˆ™
    const birthRules = mode.birthRules || [3];
    const surviveRules = mode.surviveRules || [2, 3];
    
    for (let x = 0; x < w; x++) {
        for (let y = 0; y < h; y++) {
            let n = 0;
            // è®¡ç®—æ´»é‚»å±…æ•°é‡ï¼ˆä½¿ç”¨å®‰å…¨å–æ¨¡å¤„ç†è¾¹ç•Œï¼‰
            for (let dx = -1; dx <= 1; dx++) {
                for (let dy = -1; dy <= 1; dy++) {
                    if (dx === 0 && dy === 0) continue;
                    let nx = safeMod(x + dx, w);
                    let ny = safeMod(y + dy, h);
                    n += state.grid[nx][ny];
                }
            }
            
            let c = state.grid[x][y];
            if (c === 0) {
                // æ­»ç»†èƒï¼šæ£€æŸ¥å‡ºç”Ÿè§„åˆ™
                state.nextGrid[x][y] = birthRules.includes(n) ? 1 : 0;
            } else {
                // æ´»ç»†èƒï¼šæ£€æŸ¥å­˜æ´»è§„åˆ™
                state.nextGrid[x][y] = surviveRules.includes(n) ? 1 : 0;
            }
        }
    }
    
    let t = state.grid; state.grid = state.nextGrid; state.nextGrid = t;
    
    // åŠ¨æ€å†ç”Ÿé€»è¾‘
    if (mode.autoRegen) {
        let currentRate = mode.regenRateBase;
        if (mode.dynamicRegen) {
            const len = state.snake.length;
            if (len < mode.thresholds[0]) currentRate = mode.regenRates[0];
            else if (len < mode.thresholds[1]) currentRate = mode.regenRates[1];
            else currentRate = mode.regenRates[2];
        }
        
        if (currentRate > 0 && Math.random() < currentRate) {
            spawnFood(mode.regenAmount);
        }
    }
    
    checkBodyCollision(); state.needsRender = true;
}

function updateSnakeSize() {
    const mode = state.config;
    let extra = Math.max(0, state.snake.length - mode.startLength);
    state.snake.radius = 1.0 + (extra / mode.growthThreshold) * 0.5;
    if(state.snake.radius > mode.maxSize) state.snake.radius = mode.maxSize;
}

function moveSnake(dx, dy, isKeyboard = false) {
    if(state.gameOver || !state.grid) return;
    
    const head = state.snake.path[0];
    let nextX = head.x + dx;
    let nextY = head.y + dy;
    
    if (isKeyboard) {
        nextX = safeMod(nextX, state.w);
        nextY = safeMod(nextY, state.h);
    } else {
        if (nextX < 0 || nextX >= state.w) { dx = 0; nextX = head.x; }
        if (nextY < 0 || nextY >= state.h) { dy = 0; nextY = head.y; }
        if (dx === 0 && dy === 0) {
             if (state.controlMode === 'rts') state.rtsTarget = null;
             return;
        }
    }

    if(dx !== 0 || dy !== 0) state.snake.dir = {x:dx, y:dy};
    const nx = nextX; const ny = nextY;

    // è‡ªå™¬æ£€æµ‹
    const s = state.snake;
    let hitRadiusSq = (s.radius * 0.7)**2; 
    let safeDist = Math.ceil(s.radius * 2.5) + 3;
    for(let i = safeDist; i < s.path.length; i++) {
        if((nx-s.path[i].x)**2 + (ny-s.path[i].y)**2 < hitRadiusSq) { Sound.playDie(); showGameOver("ä½ å’¬æ–­äº†è‡ªå·±"); return; }
    }

    // åå™¬
    let r = Math.ceil(s.radius); let eaten = 0; let rSq = s.radius**2;
    for(let i = -r; i <= r; i++) {
        for(let j = -r; j <= r; j++) {
            if(i*i + j*j > rSq) continue;
            let tx = nx + i; let ty = ny + j;
            if (isKeyboard) { tx = safeMod(tx, state.w); ty = safeMod(ty, state.h); }
            else { tx = clamp(tx, 0, state.w - 1); ty = clamp(ty, 0, state.h - 1); }
            
            if (tx >= 0 && tx < state.w && ty >= 0 && ty < state.h && state.grid[tx][ty] === 1) { 
                state.grid[tx][ty] = 0; eaten++; 
            }
        }
    }
    if(eaten > 0) { Sound.playEat(); state.growing += eaten; s.length += eaten; updateSnakeSize(); }
    s.path.unshift({x: nx, y: ny}); while(s.path.length > s.length) s.path.pop();
    
    updateCamera();
    checkBodyCollision(); state.needsRender = true; updateUI();
}

function updateCamera() {
    if(state.snake.path.length===0) return;
    const head = state.snake.path[0];
    const zoom = state.camera.zoom;
    const headScreenX = (head.x * state.config.cellSize - state.camera.x) * zoom;
    const headScreenY = (head.y * state.config.cellSize - state.camera.y) * zoom;
    const marginX = canvas.width * 0.25;
    const marginY = canvas.height * 0.25;
    
    if (headScreenX > canvas.width - marginX) state.camera.x = Math.floor(state.camera.x + (headScreenX - (canvas.width - marginX)) / zoom);
    if (headScreenX < marginX) state.camera.x = Math.floor(state.camera.x - (marginX - headScreenX) / zoom);
    if (headScreenY > canvas.height - marginY) state.camera.y = Math.floor(state.camera.y + (headScreenY - (canvas.height - marginY)) / zoom);
    if (headScreenY < marginY) state.camera.y = Math.floor(state.camera.y - (marginY - headScreenY) / zoom);
}

function checkBodyCollision() {
    const s = state.snake; 
    let startIdx = Math.ceil(s.radius) + 2;
    
    for(let i = startIdx; i < s.path.length; i += 2) {
        let p = s.path[i];
        if (!p) continue;
        
        if (p.x >= 0 && p.x < state.w && p.y >= 0 && p.y < state.h) {
            if(state.grid[p.x][p.y] === 1) { Sound.playDie(); showGameOver("è‡´å‘½æ„ŸæŸ“ï¼ç”Ÿå‘½ä½“å‡»ç©¿äº†è…¹éƒ¨"); return; }
        }
        
        if(s.radius > 2.5) {
             let sides = [{x:p.x+1, y:p.y}, {x:p.x-1, y:p.y}, {x:p.x, y:p.y+1}, {x:p.x, y:p.y-1}];
             for(let cp of sides) {
                 let cx = safeMod(cp.x, state.w);
                 let cy = safeMod(cp.y, state.h);
                 if(state.grid[cx][cy]===1) {
                     Sound.playDie(); showGameOver("è‡´å‘½æ„ŸæŸ“ï¼ä¾§è…¹å—æŸ"); return;
                 }
             }
        }
    }
}

function getWorldMouse(e) {
    const zoom = state.camera.zoom;
    const wx = Math.floor(e.clientX / zoom + state.camera.x);
    const wy = Math.floor(e.clientY / zoom + state.camera.y);
    return { x: wx, y: wy };
}

canvas.addEventListener('mousedown', (e) => { 
    if(state.gameOver) return;
    
    if(e.button === 0) { 
        if (state.controlMode === 'direct') {
            state.mouse.active = !state.mouse.active;
            if(state.mouse.active) {
                updateMousePos(e);
                if(!state.mouseInterval) state.mouseInterval=setInterval(handleMouseMove, 30);
            } else {
                stopMouseLoop();
            }
        } else {
            const wm = getWorldMouse(e);
            state.rtsTarget = {
                x: Math.floor(wm.x / state.config.cellSize),
                y: Math.floor(wm.y / state.config.cellSize)
            };
            if (!state.rtsPathTimer) {
                state.rtsPathTimer = setInterval(handleRTSMove, 30);
            }
        }
        state.needsRender = true;
    } else if (e.button === 2) { 
        shoot(2);
    }
});

canvas.addEventListener('mousemove', (e) => { 
    if (state.controlMode === 'direct') updateMousePos(e); 
});

function updateMousePos(e) { state.mouse.x = e.clientX; state.mouse.y = e.clientY; }
function stopMouseLoop() { if(state.mouseInterval) { clearInterval(state.mouseInterval); state.mouseInterval=null; } }

function handleMouseMove() {
    if(state.controlMode !== 'direct' || !state.mouse.active || state.gameOver) return;
    const head = state.snake.path[0];
    const zoom = state.camera.zoom;
    const headScreenX = (head.x * state.config.cellSize + state.config.cellSize/2 - state.camera.x) * zoom;
    const headScreenY = (head.y * state.config.cellSize + state.config.cellSize/2 - state.camera.y) * zoom;
    const dx = state.mouse.x - headScreenX;
    const dy = state.mouse.y - headScreenY;
    if(dx*dx + dy*dy < 900) return;
    const angle = Math.atan2(dy, dx); 
    const P4 = Math.PI/4;
    let mx = 0, my = 0;
    if(angle > -P4 && angle <= P4) mx = 1; else if(angle > P4 && angle <= 3*P4) my = 1; else if(angle > -3*P4 && angle <= -P4) my = -1; else mx = -1;
    if(mx === -state.snake.dir.x && my === -state.snake.dir.y) return;
    moveSnake(mx, my, false);
}

function handleRTSMove() {
    if (state.controlMode !== 'rts' || !state.rtsTarget || state.gameOver) {
        if(state.rtsPathTimer) { clearInterval(state.rtsPathTimer); state.rtsPathTimer = null; }
        return;
    }
    const head = state.snake.path[0];
    const tx = state.rtsTarget.x; const ty = state.rtsTarget.y;
    const dx = tx - head.x; const dy = ty - head.y;
    const distSq = dx*dx + dy*dy;
    if (distSq < 2) { state.rtsTarget = null; return; }
    
    let mx = 0, my = 0;
    if (Math.abs(dx) > Math.abs(dy)) {
        mx = dx > 0 ? 1 : -1;
        if (mx === -state.snake.dir.x) { mx = 0; if (dy !== 0) my = dy > 0 ? 1 : -1; else my = 1; }
    } else {
        my = dy > 0 ? 1 : -1;
        if (my === -state.snake.dir.y) { my = 0; if (dx !== 0) mx = dx > 0 ? 1 : -1; else mx = 1; }
    }
    moveSnake(mx, my, false);
}

function toggleCtrlMode() {
    if (state.controlMode === 'direct') {
        state.controlMode = 'rts';
        state.mouse.active = false; stopMouseLoop();
    } else {
        state.controlMode = 'direct';
        state.rtsTarget = null;
    }
    updateCtrlModeUI();
}

function updateCtrlModeUI() {
    if (state.controlMode === 'direct') { elCtrlMode.innerText = "ç‰µå¼• [Q]"; elCtrlMode.className = "ctrl-direct"; } 
    else { elCtrlMode.innerText = "RTS [Q]"; elCtrlMode.className = "ctrl-rts"; }
}

function renderLoop() { 
    try {
        if(state.needsRender && state.grid && state.config) { 
            draw(); 
            state.needsRender = false; 
        } 
    } catch (e) {
        console.error("Render Error:", e);
        ctx.fillStyle = '#050505';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
    }
    if(!state.gameOver) requestAnimationFrame(renderLoop); 
}

function draw() {
    const ctxW = canvas.width; const ctxH = canvas.height; 
    const zoom = state.camera.zoom;
    const config = state.config;
    const cellSize = config.cellSize;

    // æ¸…å±
    ctx.fillStyle = '#050505'; 
    ctx.fillRect(0, 0, ctxW, ctxH);

    ctx.save();
    try {
        ctx.scale(zoom, zoom); 
        ctx.translate(-state.camera.x, -state.camera.y);
        ctx.resetTransform();
        ctx.scale(zoom, zoom); 
        ctx.translate(-state.camera.x, -state.camera.y);
    } catch(e) { 
        console.warn("Transform failed:", e); 
        ctx.restore(); 
        return; 
    }

    // è®¡ç®—å¯è§èŒƒå›´
    let startX = Math.floor(state.camera.x / cellSize);
    let startY = Math.floor(state.camera.y / cellSize);
    let endX = Math.ceil((state.camera.x + ctxW / zoom) / cellSize) + 1;
    let endY = Math.ceil((state.camera.y + ctxH / zoom) / cellSize) + 1;
    startX = clamp(startX, 0, state.w);
    startY = clamp(startY, 0, state.h);
    endX = clamp(endX, 0, state.w);
    endY = clamp(endY, 0, state.h);

    // ç½‘æ ¼çº¿
    if (config.showGrid) {
        try {
            ctx.strokeStyle = '#111'; 
            ctx.lineWidth = Math.max(0.5 / zoom, 0.1); 
            ctx.beginPath();
            for(let x = startX; x <= endX; x += 10) { 
                const wx = x * cellSize; 
                ctx.moveTo(wx, startY * cellSize); 
                ctx.lineTo(wx, endY * cellSize); 
            }
            for(let y = startY; y <= endY; y += 10) { 
                const wy = y * cellSize; 
                ctx.moveTo(startX * cellSize, wy); 
                ctx.lineTo(endX * cellSize, wy); 
            }
            ctx.stroke();
        } catch(e) { console.warn("Grid draw failed:", e); }
    }

    // è¾¹ç•Œæ¡†
    try {
        ctx.strokeStyle = '#333'; 
        ctx.lineWidth = Math.max(1 / zoom, 0.5);
        ctx.strokeRect(0, 0, state.w * cellSize, state.h * cellSize);
    } catch(e) { console.warn("Border draw failed:", e); }

    // ç”Ÿå‘½ä½“
    try {
        ctx.fillStyle = config.lifeColor; 
        ctx.beginPath();
        let rectCount = 0;
        for (let x = startX; x < endX && rectCount < 10000; x++) {
            for (let y = startY; y < endY && rectCount < 10000; y++) {
                if (state.grid[x][y] === 1) { 
                    ctx.rect(x * cellSize, y * cellSize, cellSize, cellSize); 
                    rectCount++; 
                }
            }
        }
        ctx.fill();
    } catch(e) { console.warn("Life draw failed:", e); }

    // è›‡ä½“
    try {
        const s = state.snake; 
        if(s.path.length > 0) {
            let h = s.path[0], hx = h.x * cellSize + cellSize / 2, hy = h.y * cellSize + cellSize / 2;
            let w = Math.max(1 / zoom, s.radius * 1.3 * cellSize);
            ctx.lineCap = 'round'; ctx.lineJoin = 'round'; ctx.lineWidth = w; ctx.strokeStyle = config.snakeColor;
            ctx.beginPath(); 
            let st = s.path[1] || s.path[0]; 
            ctx.moveTo(st.x * cellSize + cellSize / 2, st.y * cellSize + cellSize / 2);
            for(let i = 2; i < s.path.length; i++) { 
                let p = s.path[i], pr = s.path[i-1]; 
                if(Math.abs(p.x - pr.x) > 5 || Math.abs(p.y - pr.y) > 5) { 
                    ctx.stroke(); ctx.beginPath(); 
                    ctx.moveTo(p.x * cellSize + cellSize / 2, p.y * cellSize + cellSize / 2); 
                } else { 
                    ctx.lineTo(p.x * cellSize + cellSize / 2, p.y * cellSize + cellSize / 2); 
                } 
            }
            ctx.stroke();
            
            let rp = s.radius * cellSize;
            ctx.save(); 
            ctx.translate(hx, hy); 
            ctx.rotate(Math.atan2(s.dir.y, s.dir.x));
            ctx.fillStyle = config.snakeColor; 
            ctx.beginPath(); 
            ctx.ellipse(0, 0, rp * 1.3, rp * 1.1, 0, 0, Math.PI * 2); 
            ctx.fill();
            ctx.fillStyle = config.snakeHeadColor; 
            ctx.beginPath(); 
            ctx.ellipse(0, 0, rp * 0.9, rp * 0.7, 0, 0, Math.PI * 2); 
            ctx.fill();
            ctx.restore();

            // ç‰µå¼•çº¿
            if (state.controlMode === 'direct' && state.mouse.active) {
                const mouseWorldX = Math.floor(state.mouse.x / zoom + state.camera.x);
                const mouseWorldY = Math.floor(state.mouse.y / zoom + state.camera.y);
                ctx.beginPath(); ctx.moveTo(hx, hy); ctx.lineTo(mouseWorldX, mouseWorldY);
                ctx.strokeStyle = config.beamColor; ctx.lineWidth = Math.max(1 / zoom, 0.5); ctx.stroke();
            }
            
            // RTSç›®æ ‡
            if (state.controlMode === 'rts' && state.rtsTarget) {
                const tx = state.rtsTarget.x * cellSize + cellSize / 2;
                const ty = state.rtsTarget.y * cellSize + cellSize / 2;
                ctx.strokeStyle = '#00ff00'; ctx.lineWidth = Math.max(1 / zoom, 0.5);
                const size = Math.max(5 / zoom, 1);
                ctx.beginPath(); 
                ctx.moveTo(tx - size, ty); ctx.lineTo(tx + size, ty);
                ctx.moveTo(tx, ty - size); ctx.lineTo(tx, ty + size);
                ctx.stroke();
                ctx.beginPath(); ctx.setLineDash([Math.max(3 / zoom, 1), Math.max(3 / zoom, 1)]);
                ctx.moveTo(hx, hy); ctx.lineTo(tx, ty);
                ctx.strokeStyle = 'rgba(0, 255, 0, 0.3)'; ctx.stroke(); ctx.setLineDash([]);
            }
        }
    } catch(e) { console.warn("Snake draw failed:", e); }

    ctx.restore();
}

window.upgradeMap = function() {
    if(state.snake.length < state.upgradeCost || !state.config) return;
    state.snake.length -= state.upgradeCost;
    if(state.snake.path.length > state.snake.length) state.snake.path.splice(state.snake.length);
    updateSnakeSize();
    let oldG = state.grid; let oldW = state.w; let oldH = state.h;
    state.w += 50; state.h += 50; state.upgradeCost += state.config.upgradeCostIncrement;
    state.grid = createGrid(state.w, state.h); state.nextGrid = createGrid(state.w, state.h);
    for(let x=0; x<oldW; x++) for(let y=0; y<oldH; y++) state.grid[x][y] = oldG[x][y];
    state.needsRender = true; updateUI();
};

window.togglePause = function() { state.lifeRunning = !state.lifeRunning; updateUI(); };
window.toggleMute = function() { Sound.muted = !Sound.muted; btnMute.innerText = Sound.muted ? "éŸ³æ•ˆ: å…³" : "éŸ³æ•ˆ: å¼€"; };

function showGameOver(reason) {
    state.gameOver = true; stopMouseLoop();
    state.mouse.active = false; state.rtsTarget = null;
    document.getElementById('death-reason').innerText = reason;
    document.getElementById('final-len').innerText = Math.floor(state.snake.length);
    overModal.style.display = 'flex';
}

function shoot(type) {
    if(!state.grid || !state.config) return;
    const cost = type === 1 ? state.config.skill1Cost : state.config.skill2Cost;
    if(state.gameOver || state.snake.length <= state.config.startLength + 5 || state.snake.length < cost + 5) return;
    state.snake.length -= cost; if(state.snake.path.length > state.snake.length) state.snake.path.splice(state.snake.length);
    updateSnakeSize();
    let head = state.snake.path[0]; let dist = Math.ceil(state.snake.radius) + (type===2 ? 18 : 6); 
    let sx = safeMod(head.x + state.snake.dir.x * dist, state.w);
    let sy = safeMod(head.y + state.snake.dir.y * dist, state.h);
    let pat = type===1 ? [{x:1,y:0}, {x:2,y:1}, {x:0,y:2}, {x:1,y:2}, {x:2,y:2}] : [{x:1,y:0}, {x:4,y:0}, {x:0,y:1}, {x:0,y:2}, {x:4,y:2}, {x:0,y:3}, {x:1,y:3}, {x:2,y:3}, {x:3,y:3}];
    let finalPat = []; let dx = state.snake.dir.x; let dy = state.snake.dir.y;
    if (type === 1) { 
        if (dx === 1) finalPat = pat; 
        else if (dx === -1) finalPat = pat.map(p => ({x: -p.x, y: p.y})); 
        else if (dy === 1) finalPat = pat.map(p => ({x: -p.y, y: p.x})); 
        else if (dy === -1) finalPat = pat.map(p => ({x: p.y, y: -p.x})); 
    } else { 
        if (dx === 1) finalPat = pat; 
        else if (dx === -1) finalPat = pat.map(p => ({x: -p.x + 4, y: p.y})); 
        else if (dy === 1) finalPat = pat.map(p => ({x: -p.y + 3, y: p.x})); 
        else if (dy === -1) finalPat = pat.map(p => ({x: p.y, y: -p.x + 4})); 
    }
    
    finalPat.forEach(p => {
        let fx = safeMod(sx + p.x, state.w);
        let fy = safeMod(sy + p.y, state.h);
        state.grid[fx][fy] = 1;
    });
    state.needsRender = true; updateUI();
}

function updateUI() {
    elLen.innerText = Math.floor(state.snake.length); 
    elMap.innerText = `${state.w}x${state.h}`; 
    elZoom.innerText = Math.round(state.camera.zoom * 100) + "%";
    if (state.config) {
        btnUpgrade.disabled = state.snake.length < state.upgradeCost; 
        btnUpgrade.innerText = `æ‰©å¤§åœ°å›¾ [E] (è€—${state.upgradeCost})`;
    }
    btnPause.innerText = state.lifeRunning ? "æš‚åœ [P]" : "ç»§ç»­ [P]";
}

document.addEventListener('keydown', (e) => {
    if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' '].includes(e.key)) e.preventDefault();
    if(e.key===' '){ shoot(1); return; }
    if(e.key==='e'||e.key==='E'){ upgradeMap(); return; }
    if(e.key==='p'||e.key==='P'){ togglePause(); return; }
    if(e.key==='q'||e.key==='Q'){ toggleCtrlMode(); return; }
    if(e.key==='r'||e.key==='R'){ if(state.gameOver) showStartMenu(); return; }
    const k = {ArrowUp:[0,-1], w:[0,-1], W:[0,-1], ArrowDown:[0,1], s:[0,1], S:[0,1], ArrowLeft:[-1,0], a:[-1,0], A:[-1,0], ArrowRight:[1,0], d:[1,0], D:[1,0]};
    if(k[e.key]) moveSnake(k[e.key][0], k[e.key][1], true);
});

// åˆå§‹åŒ–ï¼šä¸ºæ‰€æœ‰æ»‘å—æ·»åŠ äº‹ä»¶ç›‘å¬
document.addEventListener('DOMContentLoaded', function() {
    // æ›´æ–°æ‰€æœ‰æ•°å€¼æ˜¾ç¤º
    updateAllValues();
    
    // ä¸ºæ‰€æœ‰æ»‘å—æ·»åŠ äº‹ä»¶ç›‘å¬
    const sliders = document.querySelectorAll('input[type="range"]');
    sliders.forEach(slider => {
        slider.addEventListener('input', function() {
            const id = this.id;
            const valueId = id + '-val';
            const display = document.getElementById(valueId);
            if (display) display.textContent = this.value;
            const input = document.getElementById(valueId + '-val');
            if (input) input.value = this.value;
            
            // ç‰¹æ®Šå¤„ç†ï¼šæ›´æ–°é˜ˆå€¼æ˜¾ç¤º
            if (id === 'cfg-threshold1') {
                document.getElementById('cfg-threshold1-val').textContent = this.value;
                document.getElementById('cfg-threshold1-val-display').value = this.value;
            }
            if (id === 'cfg-threshold2') {
                document.getElementById('cfg-threshold2-val').textContent = this.value;
                document.getElementById('cfg-threshold2-val-display').value = this.value;
            }
            if (id === 'cfg-growthThreshold') {
                document.getElementById('cfg-growthThreshold-val').textContent = this.value;
                document.getElementById('cfg-growthThreshold-val-display').value = this.value;
            }
        });
    });
    
    // ä¸ºæ‰€æœ‰æ•°å­—è¾“å…¥æ¡†æ·»åŠ äº‹ä»¶ç›‘å¬
    const numberInputs = document.querySelectorAll('input[type="number"]');
    numberInputs.forEach(input => {
        input.addEventListener('input', function() {
            const id = this.id.replace('-val', '');
            const slider = document.getElementById(id);
            if (slider) slider.value = this.value;
            
            // æ›´æ–°æ˜¾ç¤º
            const display = document.getElementById(id + '-val');
            if (display) display.textContent = this.value;
            
            // ç‰¹æ®Šå¤„ç†
            if (id === 'cfg-threshold1') {
                document.getElementById('cfg-threshold1-val').textContent = this.value;
            }
            if (id === 'cfg-threshold2') {
                document.getElementById('cfg-threshold2-val').textContent = this.value;
            }
            if (id === 'cfg-growthThreshold') {
                document.getElementById('cfg-growthThreshold-val').textContent = this.value;
            }
        });
    });
    
    // é¢œè‰²é€‰æ‹©å™¨äº‹ä»¶
    const colorPickers = document.querySelectorAll('input[type="color"]');
    colorPickers.forEach(picker => {
        picker.addEventListener('input', updateColorPreviews);
    });
    
    // è§„åˆ™ç›¸å…³äº‹ä»¶ç›‘å¬
    document.getElementById('cfg-ruleBirth').addEventListener('input', updateRuleDisplay);
    document.getElementById('cfg-ruleSurvive').addEventListener('input', updateRuleDisplay);
    
    // è§„åˆ™å•å…ƒæ ¼ç‚¹å‡»äº‹ä»¶
    document.querySelectorAll('.rule-cell').forEach(cell => {
        cell.addEventListener('click', function() {
            const num = parseInt(this.getAttribute('data-num'));
            const isBirth = this.classList.contains('birth');
            const inputId = isBirth ? 'cfg-ruleBirth' : 'cfg-ruleSurvive';
            const input = document.getElementById(inputId);
            
            // è·å–å½“å‰è§„åˆ™æ•°ç»„
            let rules = parseRuleString(input.value);
            
            // åˆ‡æ¢è§„åˆ™
            if (rules.includes(num)) {
                rules = rules.filter(n => n !== num);
            } else {
                rules.push(num);
                rules.sort((a, b) => a - b);
            }
            
            // æ›´æ–°è¾“å…¥æ¡†
            input.value = rules.join(',');
            
            // æ›´æ–°æ˜¾ç¤º
            updateRuleDisplay();
        });
    });
    
    // é¢„è®¾è§„åˆ™ç‚¹å‡»äº‹ä»¶
    document.querySelectorAll('.rule-preset').forEach(preset => {
        preset.addEventListener('click', function() {
            const rule = this.getAttribute('data-rule');
            applyPresetRule(rule);
        });
    });
    
    // åŠ è½½ä¿å­˜çš„é…ç½®
    loadCustomConfig();
    
    // åˆå§‹è§„åˆ™æ˜¾ç¤º
    updateRuleDisplay();
});

showStartMenu();
</script>
</body>
</html>
